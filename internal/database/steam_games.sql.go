// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: steam_games.sql

package database

import (
	"context"
	"database/sql"
)

const clearSteamDB = `-- name: ClearSteamDB :exec
DELETE FROM steam_games
`

func (q *Queries) ClearSteamDB(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearSteamDB)
	return err
}

const getCountGames = `-- name: GetCountGames :one
SELECT COUNT(*) FROM steam_games
`

func (q *Queries) GetCountGames(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountGames)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTopPlayedGames = `-- name: GetTopPlayedGames :many
SELECT appid, name, playtime_forever FROM steam_games
ORDER BY playtime_forever DESC LIMIT ?
`

type GetTopPlayedGamesRow struct {
	Appid           int
	Name            string
	PlaytimeForever int
}

func (q *Queries) GetTopPlayedGames(ctx context.Context, limit int64) ([]GetTopPlayedGamesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPlayedGames, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopPlayedGamesRow
	for rows.Next() {
		var i GetTopPlayedGamesRow
		if err := rows.Scan(&i.Appid, &i.Name, &i.PlaytimeForever); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalGameTime2Weeks = `-- name: GetTotalGameTime2Weeks :one
SELECT SUM(playtime_2weeks) FROM steam_games
`

func (q *Queries) GetTotalGameTime2Weeks(ctx context.Context) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getTotalGameTime2Weeks)
	var sum sql.NullFloat64
	err := row.Scan(&sum)
	return sum, err
}

const getTotalGameTimeForever = `-- name: GetTotalGameTimeForever :one
SELECT SUM(playtime_forever) FROM steam_games
`

func (q *Queries) GetTotalGameTimeForever(ctx context.Context) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getTotalGameTimeForever)
	var sum sql.NullFloat64
	err := row.Scan(&sum)
	return sum, err
}

const getTotalGamesAll = `-- name: GetTotalGamesAll :many
SELECT name, appid from steam_games
ORDER BY name
`

type GetTotalGamesAllRow struct {
	Name  string
	Appid int
}

func (q *Queries) GetTotalGamesAll(ctx context.Context) ([]GetTotalGamesAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalGamesAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalGamesAllRow
	for rows.Next() {
		var i GetTotalGamesAllRow
		if err := rows.Scan(&i.Name, &i.Appid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalGamesNotPlayed = `-- name: GetTotalGamesNotPlayed :many
SELECT name, appid from steam_games
WHERE playtime_forever = 0
ORDER BY name
`

type GetTotalGamesNotPlayedRow struct {
	Name  string
	Appid int
}

func (q *Queries) GetTotalGamesNotPlayed(ctx context.Context) ([]GetTotalGamesNotPlayedRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalGamesNotPlayed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalGamesNotPlayedRow
	for rows.Next() {
		var i GetTotalGamesNotPlayedRow
		if err := rows.Scan(&i.Name, &i.Appid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalGamesPlayed = `-- name: GetTotalGamesPlayed :many
SELECT name, appid from steam_games
WHERE playtime_forever > 1
ORDER BY name
`

type GetTotalGamesPlayedRow struct {
	Name  string
	Appid int
}

func (q *Queries) GetTotalGamesPlayed(ctx context.Context) ([]GetTotalGamesPlayedRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalGamesPlayed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalGamesPlayedRow
	for rows.Next() {
		var i GetTotalGamesPlayedRow
		if err := rows.Scan(&i.Name, &i.Appid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGame = `-- name: InsertGame :one
INSERT INTO steam_games(appid, name, playtime_forever, img_icon_url, playtime_windows_forever, playtime_mac_forever, playtime_linux_forever, playtime_deck_forever, rtime_last_played, playtime_disconnected, playtime_2weeks)
VALUES(
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)RETURNING appid, name, playtime_forever, img_icon_url, playtime_windows_forever, playtime_mac_forever, playtime_linux_forever, playtime_deck_forever, rtime_last_played, playtime_disconnected, playtime_2weeks
`

type InsertGameParams struct {
	Appid                  int
	Name                   string
	PlaytimeForever        int
	ImgIconUrl             string
	PlaytimeWindowsForever int
	PlaytimeMacForever     int
	PlaytimeLinuxForever   int
	PlaytimeDeckForever    int
	RtimeLastPlayed        int
	PlaytimeDisconnected   int
	Playtime2weeks         int
}

func (q *Queries) InsertGame(ctx context.Context, arg InsertGameParams) (SteamGame, error) {
	row := q.db.QueryRowContext(ctx, insertGame,
		arg.Appid,
		arg.Name,
		arg.PlaytimeForever,
		arg.ImgIconUrl,
		arg.PlaytimeWindowsForever,
		arg.PlaytimeMacForever,
		arg.PlaytimeLinuxForever,
		arg.PlaytimeDeckForever,
		arg.RtimeLastPlayed,
		arg.PlaytimeDisconnected,
		arg.Playtime2weeks,
	)
	var i SteamGame
	err := row.Scan(
		&i.Appid,
		&i.Name,
		&i.PlaytimeForever,
		&i.ImgIconUrl,
		&i.PlaytimeWindowsForever,
		&i.PlaytimeMacForever,
		&i.PlaytimeLinuxForever,
		&i.PlaytimeDeckForever,
		&i.RtimeLastPlayed,
		&i.PlaytimeDisconnected,
		&i.Playtime2weeks,
	)
	return i, err
}
